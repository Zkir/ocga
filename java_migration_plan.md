# OCGA Project Java Migration Plan

This document outlines a plan to migrate the OCGA (osm-cga, or Computer Generated Architecture for OSM) project from Python to Java. The plan takes into account the project's current architecture, especially its use of ANTLR for parsing and dynamic code execution (`exec()`) for rule processing.

## Overall Approach: AST Interpretation in Java

While the Python version generates and dynamically executes Python code, the recommended approach for Java is to build an Abstract Syntax Tree (AST) and then *interpret* it directly. This is a more standard, robust, and manageable pattern for Domain-Specific Languages (DSLs) in strongly-typed languages like Java, avoiding the complexities of dynamic Java code compilation at runtime.

## Estimated Timeline: 10-14 Weeks (for an experienced developer)

This estimate assumes a single experienced developer working full-time. Interactive work with an AI agent (like myself) might extend this timeline due to communication overhead and sequential task execution.

---

## Phase 1: Analysis & Design (1-2 Weeks)

### 1.1 Deep Dive into Existing Python Code
*   **OCGA Language & Parser:**
    *   Thorough analysis of `ocgaparser/ocga.g4` to understand the full grammar.
    *   Examine `ocgaparser/main.py`'s `ocga2py` function to understand *how* OCGA constructs are translated into Python code. This provides crucial insight into the semantics of each OCGA operator.
    *   Review generated parser files (`ocgaLexer.py`, `ocgaParser.py`, `ocgaVisitor.py`) to confirm ANTLR's usage.
*   **Core Logic:**
    *   Detailed study of `ocga_engine.py` and `mdlOsmParser.py`. Identify all geometric operations, scope transformations, tag handling logic, and the `T3DObject` data structure.
    *   Pinpoint mathematical calculations (trigonometry, affine transformations) and ensure their correct translation.
*   **OSM Interaction:** Understand how `mdlOsmParser.py` reads/writes OSM XML, and how `Node`, `Way`, `Relation`, and tags are processed.

### 1.2 Technology Selection for Java
*   **Parser:** ANTLR 4 for Java. The existing `ocga.g4` can be directly used.
*   **Geometric Libraries:** Research and select suitable Java libraries for 2D/3D geometry. Options include:
    *   JTS Topology Suite (for 2D geometric operations).
    *   Apache Commons Math (for linear algebra, if custom matrix operations are needed).
    *   Custom implementation for specific geometric transformations if no suitable library is found.
*   **XML Parsing:** Choose a robust Java XML library for OSM data (e.g., JAXB, StAX, or a specialized OSM library).
*   **Data Structures:** Design Java equivalents for `T3DObject`, `OsmGeometry`, etc.

### 1.3 Java Project Architecture Design
*   Define core classes: `OcgaEngine`, `OcgaContext`, `T3DObject` (and related geometry classes like `Node`, `Way`, `Relation`), `OsmGeometry`, `OcgaAstBuilder` (to build the AST), and `OcgaAstInterpreter`.
*   Establish a class hierarchy for geometric primitives.
*   Plan a modular structure (e.g., `ocga-core`, `ocga-parser`, `ocga-osm-io`).

---

## Phase 2: Parser & AST Construction (2-3 Weeks)

### 2.1 Project Setup
*   Initialize a new Maven or Gradle project with ANTLR 4 dependencies.

### 2.2 ANTLR Parser Generation
*   Use ANTLR to generate Java lexer, parser, and base visitor/listener classes from `ocga.g4`.

### 2.3 AST Building
*   Implement a custom ANTLR `Visitor` (e.g., `OcgaAstBuilder`) that traverses the parse tree generated by ANTLR and constructs a clean, well-defined Abstract Syntax Tree (AST) representing the OCGA rules.
*   Define Java classes for AST nodes (e.g., `RuleNode`, `OperatorNode`, `ConditionalNode`, `ExpressionNode`). This is crucial for robust interpretation.

---

## Phase 3: Core Engine & Interpreter Implementation (4-6 Weeks)

### 3.1 Port `T3DObject` and `OsmGeometry`
*   Create robust Java classes for `T3DObject` with all its attributes (nodes, tags, scope, bbox) and methods (e.g., `updateBBox`, `localXY2LatLon`).
*   Implement `OsmGeometry` to manage nodes and their attributes.

### 3.2 Implement `OcgaContext`
*   Create the `OcgaContext` class in Java. This class will encapsulate the state and provide all the API methods (`split_x`, `scale`, `tag`, `insert2`, etc.) that OCGA operators call. This is the most labor-intensive part.
*   Ensure all geometric and tagging logic is correctly translated from Python.

### 3.3 Implement AST Interpreter
*   Develop `OcgaAstInterpreter` (another custom `Visitor` or `Walke`r class) that traverses the AST built in Phase 2.
*   For each AST node (representing an OCGA operator), the interpreter will call the corresponding method on the `OcgaContext` instance.
*   Implement logic for conditional statements (`if-then-else`) and loop constructs based on the AST.

### 3.4 Port Helper Functions
*   Translate utilities like `parseRelativeValue`, `calculateDimensionsForSplitPattern`, `copyBuildingPartTags`, etc., into Java.

### 3.5 Integrate OSM I/O
*   Develop Java functions for reading and writing OSM XML files, converting data to/from `T3DObject` instances.

---

## Phase 4: Testing & Debugging (2-3 Weeks)

### 4.1 Unit Tests
*   Write comprehensive unit tests for:
    *   Each OCGA operator within `OcgaContext`.
    *   `T3DObject` and `OsmGeometry` functionality.
    *   Parsing and AST building (`OcgaAstBuilder`).
    *   AST interpretation (`OcgaAstInterpreter`).

### 4.2 Integration Tests
*   Utilize the existing `.ocga` and `.osm` sample files from `ocga_samples/` for end-to-end testing.
*   Compare the output (`-rewrite.osm` files) generated by the Java version against the reference outputs from the Python version.
*   Address any discrepancies and edge cases.

### 4.3 Debugging
*   Systematically identify and fix bugs introduced during migration and testing.

---

## Phase 5: Optimization & Refinement (1-2 Weeks)

### 5.1 Performance Analysis
*   Identify and optimize any performance bottlenecks in the Java implementation.
### 5.2 Error Handling
*   Enhance error messages and implement robust validation checks.
### 5.3 Documentation
*   Create JavaDoc for all public classes and methods.
### 5.4 Command-Line Interface (CLI)
*   Develop a simple CLI for the Java application, mirroring the Python version's functionality.

---

## Alternative: Dynamic Java Code Generation (Advanced, Not Recommended)

An alternative, more complex approach would involve:
1.  Generating Java source code (`.java` files) from OCGA rules.
2.  Using the Java Compiler API (JSR 199) to compile these `.java` files into `.class` files at runtime.
3.  Dynamically loading and invoking the compiled classes using `URLClassLoader` and Java Reflection.

This approach is significantly more complex, harder to debug, and generally less maintainable than direct AST interpretation for DSLs in Java. It mimics the Python `exec()` behavior but requires substantial infrastructure in Java. Therefore, it is *not recommended* unless there's a critical performance requirement that AST interpretation cannot meet, or if there's a strong mandate to preserve the code generation paradigm.
